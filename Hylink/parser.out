Created by PLY version 3.7 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> expr
Rule 1     expr -> expr PLUS term
Rule 2     expr -> expr MINUS term
Rule 3     expr -> term
Rule 4     term -> term TIMES factor
Rule 5     term -> term DIVIDE factor
Rule 6     term -> factor
Rule 7     factor -> IDENTIFIER
Rule 8     factor -> MINUS IDENTIFIER
Rule 9     factor -> MINUS FLOAT
Rule 10    factor -> MINUS INTEGER
Rule 11    factor -> FLOAT
Rule 12    factor -> INTEGER
Rule 13    factor -> LPAREN expr RPAREN

Terminals, with rules where they appear

DIVIDE               : 5
FLOAT                : 9 11
IDENTIFIER           : 7 8
INTEGER              : 10 12
LPAREN               : 13
MINUS                : 2 8 9 10
PLUS                 : 1
RPAREN               : 13
TIMES                : 4
error                : 

Nonterminals, with rules where they appear

expr                 : 1 2 13 0
factor               : 4 5 6
term                 : 1 2 3 4 5

Parsing method: LALR

state 0

    (0) S' -> . expr
    (1) expr -> . expr PLUS term
    (2) expr -> . expr MINUS term
    (3) expr -> . term
    (4) term -> . term TIMES factor
    (5) term -> . term DIVIDE factor
    (6) term -> . factor
    (7) factor -> . IDENTIFIER
    (8) factor -> . MINUS IDENTIFIER
    (9) factor -> . MINUS FLOAT
    (10) factor -> . MINUS INTEGER
    (11) factor -> . FLOAT
    (12) factor -> . INTEGER
    (13) factor -> . LPAREN expr RPAREN

    IDENTIFIER      shift and go to state 7
    MINUS           shift and go to state 8
    FLOAT           shift and go to state 3
    INTEGER         shift and go to state 6
    LPAREN          shift and go to state 4

    expr                           shift and go to state 2
    term                           shift and go to state 1
    factor                         shift and go to state 5

state 1

    (3) expr -> term .
    (4) term -> term . TIMES factor
    (5) term -> term . DIVIDE factor

    RPAREN          reduce using rule 3 (expr -> term .)
    PLUS            reduce using rule 3 (expr -> term .)
    MINUS           reduce using rule 3 (expr -> term .)
    $end            reduce using rule 3 (expr -> term .)
    TIMES           shift and go to state 10
    DIVIDE          shift and go to state 9


state 2

    (0) S' -> expr .
    (1) expr -> expr . PLUS term
    (2) expr -> expr . MINUS term

    PLUS            shift and go to state 11
    MINUS           shift and go to state 12


state 3

    (11) factor -> FLOAT .

    TIMES           reduce using rule 11 (factor -> FLOAT .)
    DIVIDE          reduce using rule 11 (factor -> FLOAT .)
    PLUS            reduce using rule 11 (factor -> FLOAT .)
    MINUS           reduce using rule 11 (factor -> FLOAT .)
    $end            reduce using rule 11 (factor -> FLOAT .)
    RPAREN          reduce using rule 11 (factor -> FLOAT .)


state 4

    (13) factor -> LPAREN . expr RPAREN
    (1) expr -> . expr PLUS term
    (2) expr -> . expr MINUS term
    (3) expr -> . term
    (4) term -> . term TIMES factor
    (5) term -> . term DIVIDE factor
    (6) term -> . factor
    (7) factor -> . IDENTIFIER
    (8) factor -> . MINUS IDENTIFIER
    (9) factor -> . MINUS FLOAT
    (10) factor -> . MINUS INTEGER
    (11) factor -> . FLOAT
    (12) factor -> . INTEGER
    (13) factor -> . LPAREN expr RPAREN

    IDENTIFIER      shift and go to state 7
    MINUS           shift and go to state 8
    FLOAT           shift and go to state 3
    INTEGER         shift and go to state 6
    LPAREN          shift and go to state 4

    expr                           shift and go to state 13
    term                           shift and go to state 1
    factor                         shift and go to state 5

state 5

    (6) term -> factor .

    TIMES           reduce using rule 6 (term -> factor .)
    DIVIDE          reduce using rule 6 (term -> factor .)
    PLUS            reduce using rule 6 (term -> factor .)
    MINUS           reduce using rule 6 (term -> factor .)
    $end            reduce using rule 6 (term -> factor .)
    RPAREN          reduce using rule 6 (term -> factor .)


state 6

    (12) factor -> INTEGER .

    TIMES           reduce using rule 12 (factor -> INTEGER .)
    DIVIDE          reduce using rule 12 (factor -> INTEGER .)
    PLUS            reduce using rule 12 (factor -> INTEGER .)
    MINUS           reduce using rule 12 (factor -> INTEGER .)
    $end            reduce using rule 12 (factor -> INTEGER .)
    RPAREN          reduce using rule 12 (factor -> INTEGER .)


state 7

    (7) factor -> IDENTIFIER .

    TIMES           reduce using rule 7 (factor -> IDENTIFIER .)
    DIVIDE          reduce using rule 7 (factor -> IDENTIFIER .)
    PLUS            reduce using rule 7 (factor -> IDENTIFIER .)
    MINUS           reduce using rule 7 (factor -> IDENTIFIER .)
    $end            reduce using rule 7 (factor -> IDENTIFIER .)
    RPAREN          reduce using rule 7 (factor -> IDENTIFIER .)


state 8

    (8) factor -> MINUS . IDENTIFIER
    (9) factor -> MINUS . FLOAT
    (10) factor -> MINUS . INTEGER

    IDENTIFIER      shift and go to state 15
    FLOAT           shift and go to state 16
    INTEGER         shift and go to state 14


state 9

    (5) term -> term DIVIDE . factor
    (7) factor -> . IDENTIFIER
    (8) factor -> . MINUS IDENTIFIER
    (9) factor -> . MINUS FLOAT
    (10) factor -> . MINUS INTEGER
    (11) factor -> . FLOAT
    (12) factor -> . INTEGER
    (13) factor -> . LPAREN expr RPAREN

    IDENTIFIER      shift and go to state 7
    MINUS           shift and go to state 8
    FLOAT           shift and go to state 3
    INTEGER         shift and go to state 6
    LPAREN          shift and go to state 4

    factor                         shift and go to state 17

state 10

    (4) term -> term TIMES . factor
    (7) factor -> . IDENTIFIER
    (8) factor -> . MINUS IDENTIFIER
    (9) factor -> . MINUS FLOAT
    (10) factor -> . MINUS INTEGER
    (11) factor -> . FLOAT
    (12) factor -> . INTEGER
    (13) factor -> . LPAREN expr RPAREN

    IDENTIFIER      shift and go to state 7
    MINUS           shift and go to state 8
    FLOAT           shift and go to state 3
    INTEGER         shift and go to state 6
    LPAREN          shift and go to state 4

    factor                         shift and go to state 18

state 11

    (1) expr -> expr PLUS . term
    (4) term -> . term TIMES factor
    (5) term -> . term DIVIDE factor
    (6) term -> . factor
    (7) factor -> . IDENTIFIER
    (8) factor -> . MINUS IDENTIFIER
    (9) factor -> . MINUS FLOAT
    (10) factor -> . MINUS INTEGER
    (11) factor -> . FLOAT
    (12) factor -> . INTEGER
    (13) factor -> . LPAREN expr RPAREN

    IDENTIFIER      shift and go to state 7
    MINUS           shift and go to state 8
    FLOAT           shift and go to state 3
    INTEGER         shift and go to state 6
    LPAREN          shift and go to state 4

    term                           shift and go to state 19
    factor                         shift and go to state 5

state 12

    (2) expr -> expr MINUS . term
    (4) term -> . term TIMES factor
    (5) term -> . term DIVIDE factor
    (6) term -> . factor
    (7) factor -> . IDENTIFIER
    (8) factor -> . MINUS IDENTIFIER
    (9) factor -> . MINUS FLOAT
    (10) factor -> . MINUS INTEGER
    (11) factor -> . FLOAT
    (12) factor -> . INTEGER
    (13) factor -> . LPAREN expr RPAREN

    IDENTIFIER      shift and go to state 7
    MINUS           shift and go to state 8
    FLOAT           shift and go to state 3
    INTEGER         shift and go to state 6
    LPAREN          shift and go to state 4

    term                           shift and go to state 20
    factor                         shift and go to state 5

state 13

    (13) factor -> LPAREN expr . RPAREN
    (1) expr -> expr . PLUS term
    (2) expr -> expr . MINUS term

    RPAREN          shift and go to state 21
    PLUS            shift and go to state 11
    MINUS           shift and go to state 12


state 14

    (10) factor -> MINUS INTEGER .

    TIMES           reduce using rule 10 (factor -> MINUS INTEGER .)
    DIVIDE          reduce using rule 10 (factor -> MINUS INTEGER .)
    PLUS            reduce using rule 10 (factor -> MINUS INTEGER .)
    MINUS           reduce using rule 10 (factor -> MINUS INTEGER .)
    $end            reduce using rule 10 (factor -> MINUS INTEGER .)
    RPAREN          reduce using rule 10 (factor -> MINUS INTEGER .)


state 15

    (8) factor -> MINUS IDENTIFIER .

    TIMES           reduce using rule 8 (factor -> MINUS IDENTIFIER .)
    DIVIDE          reduce using rule 8 (factor -> MINUS IDENTIFIER .)
    PLUS            reduce using rule 8 (factor -> MINUS IDENTIFIER .)
    MINUS           reduce using rule 8 (factor -> MINUS IDENTIFIER .)
    $end            reduce using rule 8 (factor -> MINUS IDENTIFIER .)
    RPAREN          reduce using rule 8 (factor -> MINUS IDENTIFIER .)


state 16

    (9) factor -> MINUS FLOAT .

    TIMES           reduce using rule 9 (factor -> MINUS FLOAT .)
    DIVIDE          reduce using rule 9 (factor -> MINUS FLOAT .)
    PLUS            reduce using rule 9 (factor -> MINUS FLOAT .)
    MINUS           reduce using rule 9 (factor -> MINUS FLOAT .)
    $end            reduce using rule 9 (factor -> MINUS FLOAT .)
    RPAREN          reduce using rule 9 (factor -> MINUS FLOAT .)


state 17

    (5) term -> term DIVIDE factor .

    TIMES           reduce using rule 5 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 5 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 5 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 5 (term -> term DIVIDE factor .)
    $end            reduce using rule 5 (term -> term DIVIDE factor .)
    RPAREN          reduce using rule 5 (term -> term DIVIDE factor .)


state 18

    (4) term -> term TIMES factor .

    TIMES           reduce using rule 4 (term -> term TIMES factor .)
    DIVIDE          reduce using rule 4 (term -> term TIMES factor .)
    PLUS            reduce using rule 4 (term -> term TIMES factor .)
    MINUS           reduce using rule 4 (term -> term TIMES factor .)
    $end            reduce using rule 4 (term -> term TIMES factor .)
    RPAREN          reduce using rule 4 (term -> term TIMES factor .)


state 19

    (1) expr -> expr PLUS term .
    (4) term -> term . TIMES factor
    (5) term -> term . DIVIDE factor

    RPAREN          reduce using rule 1 (expr -> expr PLUS term .)
    PLUS            reduce using rule 1 (expr -> expr PLUS term .)
    MINUS           reduce using rule 1 (expr -> expr PLUS term .)
    $end            reduce using rule 1 (expr -> expr PLUS term .)
    TIMES           shift and go to state 10
    DIVIDE          shift and go to state 9


state 20

    (2) expr -> expr MINUS term .
    (4) term -> term . TIMES factor
    (5) term -> term . DIVIDE factor

    RPAREN          reduce using rule 2 (expr -> expr MINUS term .)
    PLUS            reduce using rule 2 (expr -> expr MINUS term .)
    MINUS           reduce using rule 2 (expr -> expr MINUS term .)
    $end            reduce using rule 2 (expr -> expr MINUS term .)
    TIMES           shift and go to state 10
    DIVIDE          shift and go to state 9


state 21

    (13) factor -> LPAREN expr RPAREN .

    TIMES           reduce using rule 13 (factor -> LPAREN expr RPAREN .)
    DIVIDE          reduce using rule 13 (factor -> LPAREN expr RPAREN .)
    PLUS            reduce using rule 13 (factor -> LPAREN expr RPAREN .)
    MINUS           reduce using rule 13 (factor -> LPAREN expr RPAREN .)
    $end            reduce using rule 13 (factor -> LPAREN expr RPAREN .)
    RPAREN          reduce using rule 13 (factor -> LPAREN expr RPAREN .)

