Simulator
*********
c2e2.py creates all the C++ files on lines 193 - 199
The files are then compiled and moved in verifyAbortBtnCallback (ln 1013 - 1035).
./C2E2 to called in verifyAbortBtnCallback (ln 1278)
In the main.cpp (ln 152), a Simulator is created and simulates the system (ln 293).
A ReachTube class parses the simulated output, bloats the tubes and generates reachtube.dat (ln 310, 350)
The system is then checked using ./invariants and ./guards (ln 359 - 360)

The following functions are in hyir.py:

printInvariants - reads from the reachtube.dat file and writes into the invariant.dat file. 
For each line read from the reachtube, the code checks whether the invariant was satisfied by the reachtube.

printGuardsResets - 

hyirXML (ln 1492) - generates the hybrid representation which is used later tused for conversion to CAPD

convertToCAPD (ln 702) - generates the simulator.cpp code

Matlab - I can set the ExtU/Y_Bruss_IO_T structs to whatever values I want. I will need to modify the rt_OneStep function to do the stepping. The stopping condition will require setting the RTM thing.

Models
******
To create an input variable, add data and set scope to input. Change the initial value to take in the input variable instead.

Workspace - in the workspace, initialize the value as <var> = [time, scalar] where time is the time-stamp (I just set it to 0) and scalar is the value that we actually want to use.

File - the data has to be stored in the format in a *.mat file
[ t_1 t_2 ... t_k]
[ a_1 a_2 ... a_k]
[  .   .   .   . ]
[  .   .   .   . ]
[ z_1 z_2 ... z_k]

The output has to be set to be in array format and is stored in the same fashion as above.

Clean up
********
-Simplify automata parsing in C2E2 (ask about it as well) because currently it 
supports only a single automata


